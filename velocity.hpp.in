#ifndef UNIT_VELOCITY_HPP
#define UNIT_VELOCITY_HPP

#include "boost/units/physical_dimensions/velocity.hpp"

#include "unit/scale.hpp"

namespace unit {
namespace velocity {

enum class Unit {
  meterPerSecond,
  centimeterPerSecond = 1151,
  kilometerPerHour = 1152
};

template< Unit velocity >
const std::string name;

#define DEFINE_NAME( unit, unitName)\
template<> \
const std::string name< Unit::unit > = #unitName;

DEFINE_NAME( meterPerSecond, meter per second )
DEFINE_NAME( centimeterPerSecond, centimeter per second )
DEFINE_NAME( kilometerPerHour, kilometer per hour )

#undef DEFINE_NAME

template< Unit velocity >
const std::string symbol;

#define DEFINE_SYMBOL( unit, unitSymbol )\
template<>\
const std::string symbol< Unit::unit > = #unitSymbol;

DEFINE_SYMBOL( meterPerSecond, m/s )
DEFINE_SYMBOL( centimeterPerSecond, cm/s )
DEFINE_SYMBOL( kilometerPerHour, km/hour )

#undef DEFINE_SYMBOL

template< Unit velocityUnit >
struct base : public boost::units::base_unit
< base< velocityUnit >,
  boost::units::velocity_dimension, static_cast< long >( velocityUnit ) > {

  static const std::string& name(){
    return unit::velocity::name< velocityUnit >;
  }

  static const std::string& symbol(){
    return unit::velocity::symbol< velocityUnit >;
  }
};

/** @{
 *  @name Velocity unit types (used as Unit parameters in the Quantity template)
 */
using MeterPerSecond =
  boost::units::unit< boost::units::velocity_dimension, unit::System >;

using CentimeterPerSecond= base< Unit::centimeterPerSecond >::unit_type;
using KilometerPerHour = base< Unit::kilometerPerHour >::unit_type;
/** @}
 */

/** @{
 *  @name Velocity unit constants used in construction of velocity quantity
 */
BOOST_UNITS_STATIC_CONSTANT( m_per_s, unit::velocity::MeterPerSecond );
BOOST_UNITS_STATIC_CONSTANT( cm_per_s, unit::velocity::CentimeterPerSecond );
BOOST_UNITS_STATIC_CONSTANT( km_per_hour, unit::velocity::KilometerPerHour );
/** @}
 */

/** 
 * @brief An quantity value in a priviledged velocity unit: m/s
 *
 * @details
 *  The velocity::Value constructor allows a user to create velocity values in 
 *  m/s using the m/s unit as well as the other velocity units (e.g. cm/s, 
 *  km/hour).
 *  
 *  For example:
 *    unit::velocity::Value a1(1.0 * unit::velocity::m_per_s);
 *    unit::velocity::Value a2(1.0 * unit::velocity::cm_per_s);
 *
 *  To retrieve the value of the time in s, the public method value()
 *  can be used. For the previous examples, value() will respectively
 *  return 1.0 for a1 and 0.01 for a2 (automatic conversion of 1 cm/s to m/s).
 *
 *  The following units are currently supported:
 *    - unit::velocity::m_per_s
 *    - unit::velocity::cm_per_s
 *    - unit::velocity::km_per_hour
 */
using Value = unit::Quantity< unit::velocity::MeterPerSecond >;

Value
read( std::istream& is );
 
}

#define DEFINE_ISTREAM_OP( quantity ) \
inline std::istream& \
operator>>( std::istream& is, unit::Quantity< velocity::quantity >& q ){ \
  q = unit::Quantity< velocity::quantity >( velocity::read( is ) );        \
  return is; \
} \

DEFINE_ISTREAM_OP( MeterPerSecond )
DEFINE_ISTREAM_OP( CentimeterPerSecond )
DEFINE_ISTREAM_OP( KilometerPerHour )

#undef DEFINE_ISTREAM_OP

/* template constant specialization */
template< >
struct InPreferred< velocity::Unit > {
  using Unit = velocity::Value;
};

#define CONVERSION_MAP_ENTRY( unitEnum, constant ) \
{ velocity::symbol< velocity::Unit::unitEnum >, velocity::Value( 1 * velocity::constant ) }

template<>
const std::unordered_map< std::string, velocity::Value > 
conversionFactorMap< velocity::Unit > =
{ CONVERSION_MAP_ENTRY(meterPerSecond, m_per_s),
  CONVERSION_MAP_ENTRY(centimeterPerSecond, cm_per_s),
  CONVERSION_MAP_ENTRY(kilometerPerHour, km_per_hour) };

#undef CONVERSION_MAP_ENTRY

template<>
const std::string quantityName< velocity::Unit > = "velocity";

}

/* rude */
namespace boost {
namespace units {

inline std::string
name_string( const reduce_unit< ::unit::velocity::MeterPerSecond >::type& ) {
  return "meter per second";
}

inline std::string
symbol_string( const reduce_unit< ::unit::velocity::MeterPerSecond >::type& ) {
  return "m/s";
}

} 
} 

BOOST_UNITS_DEFINE_CONVERSION_FACTOR( \
  ::unit::velocity::base< ::unit::velocity::Unit::centimeterPerSecond >, \
  ::unit::velocity::MeterPerSecond, double, ::unit::scale::Centi::value() );
BOOST_UNITS_DEFAULT_CONVERSION( \
  ::unit::velocity::base< ::unit::velocity::Unit::centimeterPerSecond >, \
  ::unit::velocity::MeterPerSecond );

BOOST_UNITS_DEFINE_CONVERSION_FACTOR( \
  ::unit::velocity::base< ::unit::velocity::Unit::kilometerPerHour >, \
  ::unit::velocity::MeterPerSecond, double, \
  ::unit::scale::Kilo::value() / ::unit::scale::secondsPerMinute \
                                / ::unit::scale::minutesPerHour );
BOOST_UNITS_DEFAULT_CONVERSION( \
  ::unit::velocity::base< ::unit::velocity::Unit::kilometerPerHour >, \
  ::unit::velocity::MeterPerSecond );

#include "unit/src/functions.hpp"

#endif
