#ifndef UNIT_AREA_HPP
#define UNIT_AREA_HPP

#include "boost/units/conversion.hpp"
#include "boost/units/physical_dimensions/area.hpp"

#include "unit/scale.hpp"

namespace unit {
namespace area {

enum class Unit {
  squareMeter,
  squareCentimeter = 1001,
  squareMillimeter = 1002,
  squareMicrometer = 1003,
  squareNanometer  = 1004,
  barn             = 1005
};

template< Unit area >
const std::string name;

#define DEFINE_NAME( unit, unitName)\
template<> \
const std::string name< Unit::unit > = #unitName;

DEFINE_NAME( squareMeter, square meter )
DEFINE_NAME( squareCentimeter, square centimeter )
DEFINE_NAME( squareMillimeter, square millimeter )
DEFINE_NAME( squareMicrometer, square micrometer )
DEFINE_NAME( squareNanometer, square nanometer )
DEFINE_NAME( barn, barn )

#undef DEFINE_NAME

template< Unit area >
const std::string symbol;

#define DEFINE_SYMBOL( unit, unitSymbol )\
template<>\
const std::string symbol< Unit::unit > = #unitSymbol;

DEFINE_SYMBOL( squareMeter, m2 )
DEFINE_SYMBOL( squareCentimeter, cm2 )
DEFINE_SYMBOL( squareMillimeter, mm2 )
DEFINE_SYMBOL( squareMicrometer, um2 )
DEFINE_SYMBOL( squareNanometer, nm2 )
DEFINE_SYMBOL( barn, b )

#undef DEFINE_SYMBOL

template< Unit areaUnit >
struct base : public boost::units::base_unit
< base< areaUnit >,
  boost::units::area_dimension, static_cast< long >( areaUnit ) > {
  static const std::string& name(){ return unit::area::name< areaUnit >; }
  static const std::string& symbol(){ return unit::area::symbol< areaUnit >; }
};

/** @{
 *  @name Area unit types (used as Unit parameters in the Quantity template)
 */
using SquareMeter =
  boost::units::unit< boost::units::area_dimension, unit::System >;

using SquareCentimeter = base< Unit::squareCentimeter >::unit_type;
using SquareMillimeter = base< Unit::squareMillimeter >::unit_type;
using SquareMicrometer = base< Unit::squareMicrometer >::unit_type;
using SquareNanometer = base< Unit::squareNanometer >::unit_type;
using Barn = base< Unit::barn >::unit_type;
/** @}
 */

/** @{
 *  @name Area unit constants used in construction of area quantity
 */
BOOST_UNITS_STATIC_CONSTANT( m2, unit::area::SquareMeter );
BOOST_UNITS_STATIC_CONSTANT( cm2, unit::area::SquareCentimeter );
BOOST_UNITS_STATIC_CONSTANT( mm2, unit::area::SquareMillimeter );
BOOST_UNITS_STATIC_CONSTANT( um2, unit::area::SquareMicrometer );
BOOST_UNITS_STATIC_CONSTANT( nm2, unit::area::SquareNanometer );
BOOST_UNITS_STATIC_CONSTANT( b, unit::area::Barn );
/** @}
 */

/** 
 * @brief An quantity value in a priviledged area unit: cm2
 *
 * @details
 *  The area::Value constructor allows a user to create area values in cm2 using
 *  the cm2 unit as well as the other area units (e.g. m2, mm2, um2, nm2 or b).
 *  For example:
 *    unit::area::Value a1(1.0 * unit::area::cm2);
 *    unit::area::Value a2(1.0 * unit::area::m2);
 *
 *  To retrieve the value of the area in cm2, the public method value()
 *  can be used. For the previous examples, value() will respectively
 *  return 1.0 for a1 and 1.0e+4 for a2 (automatic conversion of 1 m2 to cm2).
 *
 *  The following units are currently supported:
 *    - unit::area::m2
 *    - unit::area::cm2
 *    - unit::area::mm2
 *    - unit::area::um2
 *    - unit::area::nm2
 *    - unit::area::b
 */
using Value = unit::Quantity< unit::area::SquareCentimeter >;

Value
read( std::istream& is );
 
}

#define DEFINE_ISTREAM_OP( quantity ) \
inline std::istream& \
operator>>( std::istream& is, unit::Quantity< area::quantity >& q ){ \
  q = unit::Quantity< area::quantity >( area::read( is ) );        \
  return is; \
} \

DEFINE_ISTREAM_OP( SquareMeter )
DEFINE_ISTREAM_OP( SquareCentimeter )
DEFINE_ISTREAM_OP( SquareMillimeter )
DEFINE_ISTREAM_OP( SquareMicrometer )
DEFINE_ISTREAM_OP( SquareNanometer )
DEFINE_ISTREAM_OP( Barn )

#undef DEFINE_ISTREAM_OP

/* template constant specialization */
template< >
struct InPreferred< area::Unit > {
  using Unit = area::Value;
};

#define CONVERSION_MAP_ENTRY( unitEnum, constant ) \
{ area::symbol< area::Unit::unitEnum >, area::Value( 1 * area::constant ) }

template<>
const std::unordered_map< std::string, area::Value > 
conversionFactorMap< area::Unit > =
{ CONVERSION_MAP_ENTRY(squareMeter, m2),
  CONVERSION_MAP_ENTRY(squareCentimeter, cm2),
  CONVERSION_MAP_ENTRY(squareMillimeter, mm2),
  CONVERSION_MAP_ENTRY(squareMicrometer, um2),
  CONVERSION_MAP_ENTRY(squareNanometer, nm2),
  CONVERSION_MAP_ENTRY(barn, b) };

#undef CONVERSION_MAP_ENTRY

}

/* rude */
namespace boost {
namespace units {

inline std::string
name_string( const reduce_unit< ::unit::area::SquareMeter >::type& ) {
  return "square meter";
}

inline std::string
symbol_string( const reduce_unit< ::unit::area::SquareMeter >::type& ) {
  return "m2";
}

}
}

#define DEFINE_M2_CONVERSION( areaUnit, factor )\
  BOOST_UNITS_DEFINE_CONVERSION_FACTOR( \
    ::unit::area::base< ::unit::area::Unit::areaUnit >, \
    ::unit::area::SquareMeter, double, ::unit::scale::factor::value() ); \
  BOOST_UNITS_DEFAULT_CONVERSION( \
    ::unit::area::base< ::unit::area::Unit::areaUnit >, \
    ::unit::area::SquareMeter );

DEFINE_M2_CONVERSION( squareCentimeter, tenm4 )
DEFINE_M2_CONVERSION( squareMillimeter, Micro )
DEFINE_M2_CONVERSION( squareMicrometer, Pico )
DEFINE_M2_CONVERSION( squareNanometer, Atto )
DEFINE_M2_CONVERSION( barn, tenm28 )

#undef DEFINE_M2_CONVERSION

#include "unit/src/functions.hpp"

#endif

