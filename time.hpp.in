#ifndef UNIT_TIME_HPP
#define UNIT_TIME_HPP

#include "boost/units/conversion.hpp"
#include "boost/units/physical_dimensions/time.hpp"

#include "unit/scale.hpp"

namespace unit {
namespace time {

enum class Unit {
  second,
  nanosecond,
  microsecond,
  millisecond,
  minute = 1101,
  hour   = 1102,
  day    = 1103,
  year   = 1104,
};

template< Unit time >
const std::string name;

/** 
 * @brief 
 * A macro defining a constant string describing the name a argument unit 
 */
#define DEFINE_NAME( unit, unitName)\
template<> \
const std::string name< Unit::unit > = #unitName;

DEFINE_NAME( nanosecond, nanosecond )
DEFINE_NAME( microsecond, microsecond )
DEFINE_NAME( millisecond, millisecond )
DEFINE_NAME( second, second )
DEFINE_NAME( minute, minute )
DEFINE_NAME( hour, hour )
DEFINE_NAME( day, day )
DEFINE_NAME( year, year )

#undef DEFINE_NAME

template< Unit time >
const std::string symbol;

/** 
 * @brief 
 * A macro defining a constant string describing the symbol a argument unit 
 */
#define DEFINE_SYMBOL( unit, unitSymbol )\
template<>\
const std::string symbol< Unit::unit > = #unitSymbol;

DEFINE_SYMBOL( nanosecond, ns)
DEFINE_SYMBOL( microsecond, us )
DEFINE_SYMBOL( millisecond, ms )
DEFINE_SYMBOL( second, s )
DEFINE_SYMBOL( minute, min )
DEFINE_SYMBOL( hour, hour )
DEFINE_SYMBOL( day, d )
DEFINE_SYMBOL( year, y )

#undef DEFINE_SYMBOL

template< Unit timeUnit >
struct base : public boost::units::base_unit
< base< timeUnit >,
  boost::units::time_dimension, static_cast< long >( timeUnit ) > {
  static const std::string& name(){ return unit::time::name< timeUnit >; }
  static const std::string& symbol(){ return unit::time::symbol< timeUnit >; }
};

/** @{
 *  @name Time unit types (used as Unit parameters in the Quantity template)
 */
using Second =
  boost::units::unit< boost::units::time_dimension, unit::System >;

using Minute = base< Unit::minute >::unit_type;
using Hour = base< Unit::hour >::unit_type;
using Day = base< Unit::day >::unit_type;
using Year = base< Unit::year >::unit_type;

/** @brief A macro creating a typedef corresponding to a scaled second struct */
#define DEFINE_SCALED_SECOND( Prefix )    \
using Prefix## second = boost::units::make_scaled_unit \
                        < unit::time::Second, unit::scale::Prefix >::type;

DEFINE_SCALED_SECOND( Milli )
DEFINE_SCALED_SECOND( Micro )
DEFINE_SCALED_SECOND( Nano )

#undef DEFINE_SCALED_METER
/** @}
 */

/** @{
 *  @name Time unit constants used in construction of time quantity
 */
BOOST_UNITS_STATIC_CONSTANT( s, unit::time::Second );
BOOST_UNITS_STATIC_CONSTANT( min, unit::time::Minute );
BOOST_UNITS_STATIC_CONSTANT( hour, unit::time::Hour );
BOOST_UNITS_STATIC_CONSTANT( d, unit::time::Day );
BOOST_UNITS_STATIC_CONSTANT( y, unit::time::Year );
BOOST_UNITS_STATIC_CONSTANT( ms, unit::time::Millisecond );
BOOST_UNITS_STATIC_CONSTANT( us, unit::time::Microsecond );
BOOST_UNITS_STATIC_CONSTANT( ns, unit::time::Nanosecond );
/** @}
 */

/** 
 * @brief An quantity value in a priviledged time unit: s
 *
 * @details
 *  The time::Value constructor allows a user to create time values in s using
 *  the s unit as well as the other time units (e.g. ms, us, ns, min, hour,  day,
 *  or year).
 *  For example:
 *    unit::time::Value a1(1.0 * unit::time::s);
 *    unit::time::Value a2(1.0 * unit::time::min);
 *
 *  To retrieve the value of the time in s, the public method value()
 *  can be used. For the previous examples, value() will respectively
 *  return 1.0 for a1 and 60 for a2 (automatic conversion of 1 min to s).
 *
 *  The following units are currently supported:
 *    - unit::time::ns
 *    - unit::time::us
 *    - unit::time::ms
 *    - unit::time::s
 *    - unit::time::min
 *    - unit::time::hour
 *    - unit::time::day
 *    - unit::time::year
 */
using Value = unit::Quantity< unit::time::Second >;

/** 
 * @brief Read a time::Value from a stream 
 *
 * @details
 * The stream need not specify the quantity in the corresponding quantity. So 
 * long as the quantity is specified with a recognized time unit symbol, the
 * value will be converted appropriately.
 */
Value
read( std::istream& is );

}

/** 
 * @brief A macro to define a function to read a time quantity from a stream 
 *
 * @details
 * The stream need not specify the quantity in the corresponding quantity. So 
 * long as the quantity is specified with a recognized time unit symbol, the
 * value will be converted appropriately.
 */
#define DEFINE_ISTREAM_OP( quantity ) \
inline std::istream& \
operator>>( std::istream& is, unit::Quantity< time::quantity >& q ){ \
  q = unit::Quantity< time::quantity >( time::read( is ) );        \
  return is; \
} \

DEFINE_ISTREAM_OP( Second )
DEFINE_ISTREAM_OP( Minute )
DEFINE_ISTREAM_OP( Hour )
DEFINE_ISTREAM_OP( Day)
DEFINE_ISTREAM_OP( Year )
DEFINE_ISTREAM_OP( Millisecond )
DEFINE_ISTREAM_OP( Microsecond )
DEFINE_ISTREAM_OP( Nanosecond )

#undef DEFINE_ISTREAM_OP

/* template constant specialization */
template< >
struct InPreferred< ::unit::time::Unit > {
  using Unit = ::unit::time::Value;
};

#define CONVERSION_MAP_ENTRY( unitEnum, constant ) \
{ ::unit::time::symbol< ::unit::time::Unit::unitEnum >,\
    ::unit::time::Value( 1 * ::unit::time::constant ) }

template<>
const std::unordered_map< std::string, ::unit::time::Value > 
conversionFactorMap< ::unit::time::Unit > =
{ CONVERSION_MAP_ENTRY(second, s),
  CONVERSION_MAP_ENTRY(nanosecond, ns),
  CONVERSION_MAP_ENTRY(microsecond, us),
  CONVERSION_MAP_ENTRY(millisecond, ms),
  CONVERSION_MAP_ENTRY(minute, min),
  CONVERSION_MAP_ENTRY(hour, hour),
  CONVERSION_MAP_ENTRY(day, d),
  CONVERSION_MAP_ENTRY(year, y)};

#undef CONVERSION_MAP_ENTRY

template<>
const std::string quantityName< time::Unit > = "time";

}

#define DEFINE_S_CONVERSION( timeUnit, factor ) \
  BOOST_UNITS_DEFINE_CONVERSION_FACTOR( \
    ::unit::time::base< ::unit::time::Unit::timeUnit>, ::unit::time::Second, \
    double, factor ); \
  BOOST_UNITS_DEFAULT_CONVERSION( \
    ::unit::time::base< ::unit::time::Unit::timeUnit >, ::unit::time::Second );

DEFINE_S_CONVERSION( minute, ::unit::scale::secondsPerMinute )
DEFINE_S_CONVERSION( hour,   ::unit::scale::secondsPerMinute \
                             * ::unit::scale::minutesPerHour )
DEFINE_S_CONVERSION( day,    ::unit::scale::secondsPerMinute \
                             * ::unit::scale::minutesPerHour \
                             * ::unit::scale::hoursPerDay )
DEFINE_S_CONVERSION( year,   ::unit::scale::secondsPerMinute \
                             * ::unit::scale::minutesPerHour \
                             * ::unit::scale::hoursPerDay \
                             * ::unit::scale::daysPerYear )

#undef DEFINE_S_CONVERSION

#include "unit/src/functions.hpp"

#endif
